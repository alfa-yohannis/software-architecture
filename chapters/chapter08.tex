\chapter{Space-based Architecture}

\section{Pendahuluan}

Space-based architecture merupakan salah satu pendekatan arsitektur perangkat lunak yang dirancang untuk menghadapi tantangan skalabilitas, ketersediaan, dan performa tinggi pada sistem modern. Dalam dunia yang semakin mengandalkan pemrosesan data secara real-time dan sistem yang responsif terhadap lonjakan beban secara tiba-tiba, pendekatan tradisional seperti arsitektur monolitik atau client-server sering kali menemui keterbatasan. Space-based architecture muncul sebagai solusi yang memanfaatkan prinsip in-memory computing dan komunikasi melalui media data bersama (space) untuk menghindari bottleneck dan mempercepat akses data.

Tujuan utama dari penggunaan arsitektur ini adalah untuk menciptakan sistem yang elastis, tangguh, dan mampu diskalakan secara horizontal. Dengan mengandalkan unit pemrosesan yang independen (processing units) dan data grid yang terdistribusi, space-based architecture memungkinkan sistem untuk menyesuaikan kapasitasnya sesuai dengan beban kerja yang berubah-ubah. Hal ini sangat penting dalam konteks aplikasi yang mengalami traffic dinamis, seperti layanan pemesanan online, perbankan digital, dan sistem analisis data real-time.

Masalah utama yang ingin diselesaikan oleh space-based architecture adalah terjadinya bottleneck pada titik-titik tertentu dalam sistem, seperti database pusat atau load balancer tunggal. Selain itu, pendekatan ini juga mengatasi isu latensi tinggi akibat pemrosesan yang terfokus pada satu titik pusat. Dengan mendistribusikan beban kerja dan data secara merata ke seluruh unit dalam sistem, space-based architecture mengurangi ketergantungan pada komponen pusat dan meningkatkan ketersediaan sistem secara keseluruhan.

Pendekatan ini juga sejalan dengan prinsip desain modern dalam pengembangan sistem berskala besar, termasuk prinsip loose coupling, elastic scalability, dan fault tolerance. Oleh karena itu, space-based architecture menjadi salah satu pilihan strategis dalam merancang sistem yang handal, responsif, dan mampu bertahan dalam lingkungan operasional yang dinamis dan kompleks.

\section{Sejarah}

Konsep space-based architecture berakar dari kebutuhan akan sistem yang mampu menangani beban kerja tinggi dan bersifat elastis tanpa mengalami hambatan kinerja pada titik-titik pusat sistem. Gagasan dasarnya terinspirasi dari model blackboard architecture dalam kecerdasan buatan, di mana berbagai komponen independen dapat membaca dan menulis ke papan informasi bersama untuk menyelesaikan permasalahan secara kolektif. Pendekatan ini kemudian diadaptasi ke dalam konteks sistem perangkat lunak terdistribusi dengan menekankan pada penggunaan media penyimpanan bersama sebagai pusat interaksi data, yang dikenal sebagai \textit{space}.

Pada awal tahun 2000-an, pertumbuhan aplikasi berbasis web dan kebutuhan terhadap sistem yang selalu aktif (\textit{always-on}) memicu lahirnya teknologi in-memory data grid (IMDG), yaitu mekanisme penyimpanan data di dalam memori yang dapat diakses secara paralel oleh banyak proses. Teknologi ini mendukung ide untuk membangun sistem yang tidak lagi bergantung pada database relasional sebagai pusat penyimpanan data, melainkan menyebarkan data ke seluruh node dalam bentuk grid. Hal ini mempercepat akses dan pemrosesan data secara signifikan.

Salah satu pelopor utama dalam implementasi arsitektur ini adalah GigaSpaces Technologies, yang memperkenalkan produk XAP (eXtreme Application Platform). Platform ini menggabungkan konsep processing unit, space, dan middleware virtualisasi untuk membangun sistem yang sepenuhnya terdistribusi. Keberhasilan GigaSpaces dalam mendukung sistem pemrosesan transaksi berskala besar mendorong munculnya platform serupa seperti Oracle Coherence dan Hazelcast, yang juga mengadopsi pendekatan space-based.

Seiring waktu, space-based architecture mulai mendapatkan perhatian dalam komunitas pengembang perangkat lunak dan perusahaan teknologi karena kemampuannya dalam menangani kebutuhan sistem yang bersifat \textit{elastic}, \textit{resilient}, dan \textit{scalable}. Dengan kemajuan teknologi seperti containerization, orchestrator seperti Kubernetes, serta peningkatan kapasitas memori dan jaringan, penerapan arsitektur ini menjadi semakin relevan dalam pengembangan sistem modern yang berorientasi pada performa tinggi dan toleransi terhadap kegagalan.

\section{Penerapan}

Space-based architecture telah digunakan secara luas dalam berbagai konteks aplikasi yang memerlukan skalabilitas tinggi dan waktu respons yang rendah. Salah satu penerapan paling nyata adalah pada sistem e-commerce berskala besar. Dalam skenario seperti promosi besar-besaran, flash sale, atau hari belanja nasional, sistem e-commerce sering menghadapi lonjakan trafik secara tiba-tiba yang dapat menyebabkan server kelebihan beban dan bahkan gagal beroperasi. Dengan menggunakan space-based architecture, setiap permintaan dari pengguna dapat dimasukkan ke dalam \textit{space} dan diproses oleh unit-unit pemrosesan (processing unit) secara paralel, sehingga beban sistem terdistribusi secara merata dan tidak menimbulkan bottleneck pada satu titik.

Selain itu, space-based architecture juga sangat cocok diterapkan pada aplikasi yang berbasis waktu nyata (real-time) dan berbasis event (event-driven). Contohnya adalah dalam sistem notifikasi push, layanan streaming, atau pemantauan sistem secara langsung. Dengan memanfaatkan space sebagai kanal komunikasi dan penyimpanan data yang bersifat sementara, sistem dapat bereaksi terhadap peristiwa yang terjadi dengan latensi yang sangat rendah. Proses asinkron dan pemrosesan paralel menjadi sangat mudah diterapkan, karena tidak memerlukan koordinasi yang kompleks antar komponen.

Integrasi space-based architecture dengan teknologi cloud dan arsitektur microservices juga menunjukkan sinergi yang kuat. Dalam konteks cloud, space dapat tersebar di berbagai zona ketersediaan (availability zones) untuk menjamin ketahanan data dan kesinambungan layanan. Sementara itu, dalam pendekatan microservices, setiap layanan mikro dapat berinteraksi dengan space tanpa saling tergantung secara langsung, yang membantu mengurangi keterkaitan antar layanan dan meningkatkan fleksibilitas dalam pengembangan serta deployment. Kombinasi ini menghasilkan sistem yang dapat diatur, diukur, dan diperluas secara dinamis sesuai kebutuhan, tanpa perlu mengorbankan keandalan atau performa sistem.

Dengan demikian, penerapan space-based architecture terbukti sangat relevan dalam membangun sistem modern yang menuntut kecepatan, keandalan, dan skalabilitas, baik dalam lingkungan lokal maupun berbasis cloud.


\section{Keunggulan}

Space-based architecture menawarkan sejumlah keunggulan signifikan dibandingkan pendekatan arsitektur tradisional, terutama dalam konteks aplikasi yang memerlukan performa tinggi, skalabilitas, dan ketersediaan sistem yang konsisten. Keunggulan-keunggulan ini menjadikan space-based architecture sebagai solusi strategis untuk sistem berskala besar dan bersifat dinamis. Berikut adalah tiga keunggulan utama yang paling menonjol:

\begin{enumerate}
	\item \textbf{Skalabilitas Horizontal.}  
	Dalam arsitektur ini, unit pemrosesan (\textit{processing unit}) dapat ditambahkan atau dikurangi secara dinamis tanpa memengaruhi kinerja sistem secara keseluruhan. Setiap unit bekerja secara independen dan terhubung ke \textit{space} yang terdistribusi, sehingga tidak ada ketergantungan terhadap titik pusat yang dapat menjadi bottleneck. Dengan demikian, ketika terjadi lonjakan trafik atau permintaan, sistem dapat menskalakan kapasitasnya hanya dengan menambahkan node baru ke dalam cluster tanpa downtime atau konfigurasi ulang yang kompleks.
	
	\item \textbf{Ketersediaan Tinggi (High Availability).}  
	Karena tidak bergantung pada satu titik pusat seperti database tunggal atau load balancer statis, space-based architecture mampu menjaga operasional sistem meskipun terjadi kegagalan pada sebagian komponen. Data yang disimpan secara in-memory dan disebar ke beberapa node dapat direplikasi secara otomatis. Jika salah satu node mengalami gangguan, data tetap tersedia dari node lainnya. Hal ini menjadikan arsitektur ini sangat ideal untuk aplikasi kritikal yang harus selalu aktif dan tidak boleh mengalami waktu henti.
	
	\item \textbf{Performa Melalui In-Memory Processing.}  
	Space-based architecture unggul berkat pemanfaatan in-memory data grid untuk menyimpan seluruh status, objek bisnis, dan pesan komunikasi antar komponen. Karena pengolahan data dilakukan langsung di dalam memori utama, waktu akses dan pemrosesan dapat berlangsung dalam skala milidetik atau bahkan mikrodetik. Pendekatan ini memungkinkan sistem menangani beban transaksi yang sangat tinggi dengan latensi rendah, menjadikannya cocok untuk aplikasi real-time seperti sistem finansial, analitik data cepat, atau pemantauan sensor secara langsung.
\end{enumerate}

Ketiga keunggulan tersebut—skalabilitas horizontal, ketersediaan tinggi, dan performa tinggi—berkontribusi secara signifikan terhadap ketangguhan dan efisiensi space-based architecture sebagai fondasi untuk membangun sistem modern yang fleksibel, andal, dan mampu berkembang sesuai kebutuhan bisnis.



\section{Kelemahan}

Meskipun space-based architecture menawarkan berbagai keunggulan dalam hal skalabilitas, ketersediaan, dan performa, pendekatan ini juga memiliki sejumlah kelemahan yang perlu dipertimbangkan secara matang sebelum diimplementasikan. Beberapa tantangan utama terkait dengan kompleksitas teknis, kebutuhan sumber daya, serta aspek konsistensi dan replikasi data dalam lingkungan terdistribusi. Berikut ini adalah tiga kelemahan utama dari space-based architecture:

\begin{enumerate}
	\item \textbf{Kompleksitas Pengelolaan.}  
	Space-based architecture melibatkan banyak komponen yang bekerja secara paralel dan berkoordinasi melalui \textit{space}. Hal ini berbeda dengan arsitektur monolitik atau client-server yang umumnya bersifat linear dan lebih mudah dipantau. Implementasi space-based membutuhkan perencanaan sistem yang matang, strategi pengelolaan beban kerja yang efisien, serta pemahaman teknis yang mendalam mengenai komunikasi asinkron dan manajemen komponen terdistribusi. Tantangan juga muncul dalam proses debugging, monitoring, dan pemeliharaan sistem karena perilaku komponen yang tersebar dan tidak selalu deterministik.
	
	\item \textbf{Kebutuhan Memori yang Besar.}  
	Karena space-based architecture bergantung pada penyimpanan dan pemrosesan data secara langsung di memori (RAM), kebutuhan terhadap kapasitas memori menjadi sangat tinggi. Semua status sistem, objek bisnis, dan antrian pesan disimpan di memori utama, bukan di media penyimpanan konvensional seperti hard disk. Hal ini memang memberikan kecepatan yang tinggi, namun di sisi lain menuntut investasi hardware yang signifikan, baik dari sisi kapasitas RAM maupun biaya operasionalnya. Dalam skenario skala besar, keterbatasan fisik dan konsumsi energi juga menjadi tantangan tersendiri.
	
	\item \textbf{Kesulitan Replikasi dan Konsistensi Data.}  
	Dalam sistem yang terdistribusi dan bersifat asinkron, menjaga konsistensi data antar node bukanlah tugas yang mudah. Tidak adanya pengelola data pusat berarti setiap node harus memiliki mekanisme replikasi dan sinkronisasi sendiri. Jika tidak ditangani dengan baik, potensi terjadinya konflik data, inkonsistensi, atau bahkan kehilangan data menjadi sangat tinggi. Strategi seperti \textit{eventual consistency}, \textit{versioning}, atau \textit{distributed locking} harus diterapkan dengan hati-hati. Kompleksitas ini semakin meningkat ketika sistem dijalankan dalam lingkungan multi-region atau hybrid cloud, yang memiliki karakteristik latensi dan kegagalan yang berbeda-beda.
\end{enumerate}

Dengan mempertimbangkan ketiga kelemahan tersebut, penerapan space-based architecture membutuhkan kesiapan dari segi perencanaan teknis, alokasi sumber daya, serta kompetensi tim pengembang. Evaluasi menyeluruh terhadap kebutuhan dan karakteristik sistem sangat penting agar pendekatan ini benar-benar memberikan manfaat optimal.


\section{Topology dan Komponen}
Arsitektur Space-Based Architecture memiliki struktur topologi (Gambar \ref{fig:space-based_architecture}) yang tersusun atas berbagai komponen terdistribusi yang bekerja secara paralel dan saling terkoordinasi. Topologi ini dirancang untuk mendukung prinsip skalabilitas horizontal, ketahanan terhadap kegagalan, serta kinerja tinggi melalui pemrosesan data di dalam memori dan replikasi data antar node. Setiap komponen memiliki peran spesifik yang saling melengkapi dalam membangun sistem yang tangguh, fleksibel, dan responsif terhadap beban kerja yang dinamis. Gambar berikut menyajikan ilustrasi dari topologi umum arsitektur ini, diikuti dengan penjelasan masing-masing komponennya.


\begin{figure}[h]
	\centering
	\includegraphics[width=.9\textwidth]{../images/spaced-based\_architecture.jpg}
	\caption{Space-based Architecture}
	\label{fig:space-based_architecture}
\end{figure}

\begin{itemize}
	\item \textbf{Processing Unit (PU)}: Unit pemrosesan yang menggabungkan logika aplikasi (web dan backend) serta data yang dibutuhkan. PU dapat direplikasi dan dipartisi untuk skalabilitas dan toleransi terhadap kegagalan. Setiap PU bekerja secara independen dan memiliki cache data-nya sendiri.
	
	\item \textbf{In-Memory Data Grid Cache}: Penyimpanan data sementara yang berada di dalam memori dan digunakan oleh PU untuk mempercepat akses data. Cache ini menggantikan ketergantungan langsung terhadap database dalam pemrosesan utama.
	
	\item \textbf{Data Replication Engine}: Komponen dalam PU yang bertugas mereplikasi data antar PU untuk menjaga konsistensi dan ketersediaan data di dalam in-memory grid secara terdistribusi.
	
	\item \textbf{Virtualized Middleware}: Lapisan infrastruktur yang menyediakan layanan bersama untuk seluruh arsitektur. Middleware ini menangani orkestrasi proses, penyaluran pesan, sinkronisasi data, dan pengelolaan deployment unit pemrosesan.
	
	\item \textbf{Processing Grid}: Bagian dari middleware yang bertanggung jawab mengoordinasikan eksekusi permintaan yang melibatkan lebih dari satu PU. Ini memastikan bahwa tugas dapat diselesaikan secara paralel dan efisien.
	
	\item \textbf{Messaging Grid}: Komponen yang menerima permintaan masuk dan menentukan PU aktif mana yang harus menangani permintaan tersebut. Fungsinya mirip load balancer tetapi dalam konteks sistem terdistribusi.
	
	\item \textbf{Data Grid}: Sistem memori terdistribusi yang bertindak sebagai ruang bersama (tuple space) untuk menyimpan dan menyinkronkan data antar PU. Data grid dapat dipartisi dan direplikasi untuk skalabilitas dan ketersediaan tinggi.
	
	\item \textbf{Deployment Manager}: Komponen yang bertanggung jawab untuk menyalakan atau mematikan PU berdasarkan kebutuhan beban sistem. Deployment manager memastikan sistem dapat menyesuaikan kapasitas secara elastis.
	
	\item \textbf{Data Pump}: Komponen yang menjembatani antara PU dan database. Ia bertugas mengirimkan pembaruan data dari PU ke database secara asinkron, mendukung prinsip eventual consistency.
	
	\item \textbf{Data Reader}: Komponen yang membaca data dari database dan mengirimkannya ke PU, biasanya hanya digunakan saat pemulihan sistem atau redeploy cache seluruh PU.
	
	\item \textbf{Data Writer}: Komponen yang menerima data dari data pump dan menuliskannya ke database sebagai bentuk persistensi.
	
	\item \textbf{Database}: Sistem penyimpanan utama dan akhir (system of record) untuk seluruh data aplikasi. Pada arsitektur ini, database tidak diakses secara langsung dalam alur utama melainkan diperbarui secara eventual melalui data writer.
\end{itemize}

Pada arsitektur Space-Based Architecture, alur permintaan dimulai dari klien yang mengirimkan request melalui web gateway atau load balancer. Permintaan tersebut kemudian diteruskan ke lapisan \texttt{virtualized middleware}, khususnya ke \texttt{messaging grid}, yang berfungsi menentukan unit pemrosesan (\texttt{processing unit}, \texttt{PU}) aktif yang akan menangani permintaan tersebut. Setelah \texttt{PU} ditentukan, permintaan diproses secara independen oleh \texttt{PU} tersebut.

Setiap \texttt{PU} merupakan entitas mandiri yang menggabungkan komponen logika aplikasi (baik web maupun backend), cache data in-memory melalui \texttt{in-memory data grid}, serta mesin replikasi data. \texttt{PU} menggunakan data dari \texttt{shared memory space}, yang dibangun di atas \texttt{data grid} terdistribusi, untuk mempercepat akses dan menjaga konsistensi antar node. \texttt{PU} dapat membaca dan menulis data ke \texttt{data grid} tanpa perlu bergantung langsung pada \texttt{database}.

Jika selama pemrosesan terjadi pembaruan data, \texttt{PU} yang memproses permintaan tersebut bertindak sebagai pemilik data terbaru. \texttt{PU} kemudian meneruskan pembaruan tersebut melalui \texttt{data pump}, yang bertugas menyampaikan informasi ke \texttt{data writer}. \texttt{Data writer} kemudian menyimpan data ke dalam sistem \texttt{database} secara asynchronous. Di sisi lain, \texttt{data reader} digunakan hanya dalam kondisi tertentu, seperti saat semua \texttt{PU} mengalami kegagalan atau ketika diperlukan sinkronisasi ulang cache, untuk membaca data dari \texttt{database} dan mengirimkannya ke \texttt{PU}.

Untuk mendukung skalabilitas dan elastisitas, \texttt{deployment manager} secara dinamis dapat menambah atau mengurangi jumlah \texttt{PU} sesuai dengan beban sistem. Dengan demikian, arsitektur ini mampu menangani jutaan permintaan secara paralel dengan tingkat toleransi kesalahan yang tinggi, performa cepat, dan fleksibilitas pengelolaan sumber daya.


\section{Aplikasi Sederhana}

Tujuan dari bagian ini adalah untuk memberikan pemahaman praktis mengenai penerapan \texttt{space-based architecture} melalui sebuah contoh aplikasi web sederhana yang dibangun menggunakan bahasa pemrograman Rust (Gambar \ref{fig:simple_space-based_architecture}). Aplikasi ini mengilustrasikan konsep unit pemrosesan terdistribusi yang saling berbagi ruang memori melalui pendekatan \texttt{in-memory data grid}, dengan basis data yang direplikasi secara otomatis menggunakan Galera Cluster.

Aplikasi yang dibuat berupa layanan web yang memiliki halaman utama dengan tombol untuk menambah nilai sebuah \texttt{counter}, serta halaman lain untuk menampilkan nilai \texttt{counter} tersebut. Seluruh data disimpan pada basis data MariaDB yang dikonfigurasi sebagai Galera Cluster dengan tiga node untuk mendukung replikasi sinkron dan konsistensi data antar instansi.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{../images/out/space-based_architecture.png}
	\caption{Simple Space-based Architecture with Actix Web and Galera Cluster}
	\label{fig:simple_space-based_architecture}
\end{figure}

Teknologi utama yang digunakan meliputi:
\begin{itemize}
	\item \texttt{Actix Web} sebagai kerangka kerja web asynchronous untuk membangun layanan HTTP ringan namun sangat cepat.
	\item \texttt{SQLx} sebagai library ORM berbasis makro dan compile-time safe query, dengan dukungan terhadap mode offline agar aplikasi tetap dapat dikompilasi meskipun basis data belum tersedia.
	\item \texttt{MariaDB Galera Cluster} sebagai sistem penyimpanan data yang terdistribusi dan sinkron, yang mendemonstrasikan prinsip replikasi dan shared memory seperti pada arsitektur space-based.
	\item \texttt{Docker Compose} sebagai alat orkestrasi untuk mempermudah pengaturan dan peluncuran layanan basis data secara paralel dan terisolasi.
\end{itemize}

Melalui implementasi ini, mahasiswa diharapkan dapat memahami bagaimana konsep \texttt{processing unit}, \texttt{shared memory}, dan \texttt{eventual consistency} diterapkan secara nyata. Selain itu, mahasiswa juga dapat mempelajari cara membangun sistem yang resilien dan skalabel melalui pemanfaatan replikasi data, in-memory processing, dan distribusi beban kerja di antara unit-unit layanan. Pendekatan ini menggambarkan prinsip fundamental dari \texttt{space-based architecture}, khususnya dalam skenario aplikasi yang bersifat stateful, real-time, dan memerlukan toleransi kesalahan tinggi.


\subsection{Menyiapkan Galera Cluster}

Untuk mendemonstrasikan replikasi data dan prinsip \texttt{shared memory} dalam space-based architecture, digunakan \texttt{MariaDB Galera Cluster} yang berjalan di atas Docker. Cluster ini terdiri atas tiga node: \texttt{galera1}, \texttt{galera2}, dan \texttt{galera3}. Masing-masing node memiliki peran identik dan dapat mereplikasi data antar node secara otomatis dan sinkron.

Pengaturan dilakukan menggunakan \texttt{docker-compose}, dengan konfigurasi sebagai berikut:

\begin{lstlisting}[language=yaml, caption={Konfigurasi docker-compose untuk Galera Cluster}, label={lst:galera-cluster}, basicstyle=\scriptsize\ttfamily]
	version: '3.8'
	
	services:
	galera1:
	image: bitnami/mariadb-galera:latest
	container_name: galera1
	ports:
	- "3307:3306"
	environment:
	- MARIADB_ROOT_PASSWORD=root
	- MARIADB_GALERA_CLUSTER_NAME=my_cluster
	- MARIADB_GALERA_CLUSTER_ADDRESS=gcomm://galera1,galera2,galera3
	- MARIADB_GALERA_NODE_NAME=galera1
	- MARIADB_GALERA_MARIABACKUP_PASSWORD=backup123
	- ALLOW_EMPTY_PASSWORD=yes
	- MARIADB_GALERA_FORCE_BOOTSTRAP=yes
	volumes:
	- galera1-data:/bitnami/mariadb
	networks:
	- galera-net
	
	galera2:
	image: bitnami/mariadb-galera:latest
	container_name: galera2
	ports:
	- "3308:3306"
	environment:
	- MARIADB_ROOT_PASSWORD=root
	- MARIADB_GALERA_CLUSTER_NAME=my_cluster
	- MARIADB_GALERA_CLUSTER_ADDRESS=gcomm://galera1,galera2,galera3
	- MARIADB_GALERA_NODE_NAME=galera2
	- MARIADB_GALERA_MARIABACKUP_PASSWORD=backup123
	- ALLOW_EMPTY_PASSWORD=yes
	volumes:
	- galera2-data:/bitnami/mariadb
	networks:
	- galera-net
	
	galera3:
	image: bitnami/mariadb-galera:latest
	container_name: galera3
	ports:
	- "3309:3306"
	environment:
	- MARIADB_ROOT_PASSWORD=root
	- MARIADB_GALERA_CLUSTER_NAME=my_cluster
	- MARIADB_GALERA_CLUSTER_ADDRESS=gcomm://galera1,galera2,galera3
	- MARIADB_GALERA_NODE_NAME=galera3
	- MARIADB_GALERA_MARIABACKUP_PASSWORD=backup123
	- ALLOW_EMPTY_PASSWORD=yes
	volumes:
	- galera3-data:/bitnami/mariadb
	networks:
	- galera-net
	
	volumes:
	galera1-data:
	galera2-data:
	galera3-data:
	
	networks:
	galera-net:
\end{lstlisting}

Perhatikan bahwa \texttt{galera1} di-bootstrapped terlebih dahulu dengan opsi \texttt{MARIADB\_GALERA\_FORCE\_BOOTSTRAP=yes}. Node lainnya (\texttt{galera2} dan \texttt{galera3}) akan otomatis bergabung ke cluster setelah node pertama aktif. 

Cluster ini akan menjadi tulang punggung dari replikasi data aplikasi web yang akan dibangun menggunakan Actix Web dan SQLx. Seluruh node akan berbagi data yang sama secara konsisten, mendemonstrasikan konsep data grid terdistribusi dalam praktik nyata.


\subsection{Menjalankan dan Menginisialisasi Galera}

Untuk mempermudah proses penghapusan dan inisialisasi ulang cluster Galera, dua skrip telah disiapkan, yaitu \texttt{remove\_all.sh} dan \texttt{run\_all.sh}. Skrip ini dapat digunakan untuk membersihkan semua kontainer dan volume lama, serta menjalankan ulang cluster dengan urutan dan jeda yang tepat agar sinkronisasi berjalan mulus.

\begin{lstlisting}[language=bash, caption={Skrip untuk menghapus seluruh kontainer, volume, dan jaringan Docker yang digunakan}, label={lst:remove-all}]
	# remove_all.sh
	
	sudo docker compose down -v --remove-orphans
	sudo docker volume prune -f
	sudo docker network prune -f
\end{lstlisting}

Setelah sistem bersih, gunakan skrip berikut untuk memulai ulang Galera cluster, membuat database dan tabel, serta menyisipkan data awal ke dalam tabel \texttt{counter}. Perintah juga mencakup pengecekan replikasi antar node.

\begin{lstlisting}[language=bash, caption={Skrip untuk menjalankan Galera cluster dan menginisialisasi database}, label={lst:run-all}, basicstyle=\scriptsize\ttfamily]
	# run_all.sh
	
	sudo docker compose up -d galera1
	sleep 32
	sudo docker compose up -d galera2
	sleep 32
	sudo docker compose up -d galera3
	sleep 32
	
	sudo docker exec -it galera1 /opt/bitnami/mariadb/bin/mariadb -uroot -proot -e "
	CREATE DATABASE IF NOT EXISTS app_db;
	USE app_db;
	CREATE TABLE IF NOT EXISTS counter (
	name VARCHAR(64) PRIMARY KEY,
	value BIGINT
	);
	INSERT INTO counter (name, value) VALUES ('web', 1);
	SELECT * FROM counter;
	"
	
	sleep 10
	sudo docker exec -it galera1 /opt/bitnami/mariadb/bin/mariadb -uroot -proot -e "USE app_db; SELECT * FROM counter;"
	sudo docker exec -it galera2 /opt/bitnami/mariadb/bin/mariadb -uroot -proot -e "USE app_db; SELECT * FROM counter;"
	sudo docker exec -it galera3 /opt/bitnami/mariadb/bin/mariadb -uroot -proot -e "USE app_db; SELECT * FROM counter;"
\end{lstlisting}

Dengan menjalankan \texttt{run\_all.sh}, sistem akan memastikan bahwa Galera Cluster telah tersinkronisasi dan siap digunakan oleh aplikasi web berbasis Rust/Actix Web yang akan dibangun. Tabel \texttt{counter} juga akan direplikasi secara otomatis ke seluruh node, mendemonstrasikan prinsip shared memory terdistribusi dalam space-based architecture.


\subsection{Membuat Proyek Rust dan Konfigurasi}

Langkah pertama dalam membuat aplikasi berbasis Rust adalah dengan menginisialisasi proyek menggunakan perintah:

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={Membuat proyek baru Rust}, label={lst:cargo-new}]
	cargo new rust-example
	cd rust-example
\end{lstlisting}

Perintah ini akan membuat struktur direktori awal proyek dengan file \texttt{Cargo.toml} dan direktori \texttt{src/} yang berisi \texttt{main.rs}.

Setelah struktur proyek dibuat, langkah selanjutnya adalah menambahkan dependensi yang dibutuhkan ke dalam file \texttt{Cargo.toml}. Dependensi ini mencakup:

\begin{itemize}
	\item \texttt{actix-web}: Framework untuk membangun HTTP server.
	\item \texttt{actix-files}: Untuk menyajikan file statis seperti CSS.
	\item \texttt{tera}: Templating engine untuk merender halaman HTML.
	\item \texttt{serde} dan \texttt{serde\_json}: Untuk serialisasi dan deserialisasi data.
	\item \texttt{sqlx}: ORM asynchronous untuk mengakses database MySQL/MariaDB.
	\item \texttt{tokio}: Runtime asynchronous untuk \texttt{actix-web} dan \texttt{sqlx}.
	\item \texttt{dotenv}: Untuk membaca konfigurasi koneksi database dari file \texttt{.env}.
\end{itemize}

Dependensi ini dapat ditambahkan secara otomatis menggunakan perintah berikut:

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={Menambahkan dependensi menggunakan cargo add}, label={lst:cargo-add}]
	cargo add actix-web
	cargo add actix-files
	cargo add tera
	cargo add serde --features derive
	cargo add serde_json
	cargo add sqlx --features "mysql runtime-tokio-native-tls"
	cargo add tokio --features full
	cargo add dotenv
\end{lstlisting}

Setelah perintah di atas dijalankan, file \texttt{Cargo.toml} akan berisi daftar dependensi seperti berikut:

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={Isi Cargo.toml setelah penambahan dependensi}, label={lst:cargo-toml}]
	[package]
	name = "rust-example"
	version = "0.1.0"
	edition = "2021"
	
	[dependencies]
	actix-web = "4"
	actix-files = "0.6"
	tera = "1.19"
	serde = { version = "1", features = ["derive"] }
	serde_json = "1.0"
	sqlx = { version = "0.7", features = ["mysql", "runtime-tokio-native-tls"] }
	tokio = { version = "1", features = ["full"] }
	dotenv = "0.15"
\end{lstlisting}

Setelah tahap ini, proyek siap untuk dikembangkan lebih lanjut dengan mengimplementasikan koneksi database, routing, dan fitur aplikasi sesuai dengan prinsip space-based architecture.


\subsection{Instalasi dan Setup \texttt{sqlx-cli}}

Agar dapat menggunakan makro \texttt{query!} dari SQLx secara offline, diperlukan instalasi tool \texttt{sqlx-cli}. Tool ini memungkinkan validasi dan kompilasi statik terhadap query SQL dengan cara melakukan \textit{prepare} dari skema database. Langkah-langkahnya dijelaskan sebagai berikut.

\subsubsection*{1. Instalasi \texttt{sqlx-cli}}

Instalasi dilakukan menggunakan perintah berikut:

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={Menginstal sqlx-cli untuk MySQL}, label={lst:install-sqlx-cli}]
	cargo install sqlx-cli --no-default-features --features mysql
\end{lstlisting}

Opsi \texttt{--no-default-features} digunakan untuk menghindari pemasangan fitur database lain (seperti PostgreSQL atau SQLite) yang tidak diperlukan. Fitur \texttt{mysql} wajib ditentukan secara eksplisit.

\subsubsection*{2. Menentukan Database URL}

SQLx membutuhkan akses ke skema database saat proses \texttt{prepare}. URL koneksi database dapat disimpan dalam file \texttt{.env}:

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={File .env}, label={lst:env-file}]
	DATABASE_URL="mysql://root:root@127.0.0.1:3307/app_db"
\end{lstlisting}

Pastikan database \texttt{app\_db} dan tabel \texttt{counter} sudah tersedia dalam MariaDB Galera cluster.

\subsubsection*{3. Menjalankan Perintah \texttt{prepare}}

Setelah environment disiapkan, jalankan perintah \texttt{prepare} untuk menghasilkan metadata query:

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={Menjalankan sqlx prepare}, label={lst:sqlx-prepare}]
	cargo sqlx prepare -- --lib
\end{lstlisting}

Perintah ini akan membuat direktori \texttt{.sqlx/} di dalam proyek yang menyimpan informasi statis dari semua query SQL. Hal ini memungkinkan Rust memvalidasi query SQL pada saat kompilasi, sekaligus mendukung fitur query offline di masa depan.

\subsubsection*{4. Konfigurasi Alternatif di \texttt{Cargo.toml}}

Agar tidak bergantung pada file \texttt{.env}, konfigurasi \texttt{DATABASE\_URL} juga bisa disimpan langsung di \texttt{Cargo.toml} sebagai metadata:

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={Konfigurasi database URL di Cargo.toml}, label={lst:sqlx-meta}]
	[package.metadata.sqlx]
	database-url = "mysql://root:root@127.0.0.1:3307/app_db"
\end{lstlisting}

Dengan konfigurasi ini, SQLx dapat mendeteksi \texttt{DATABASE\_URL} secara otomatis tanpa perlu file \texttt{.env}.

Setelah seluruh setup selesai, aplikasi siap melakukan query terhadap Galera cluster menggunakan \texttt{sqlx}.


\subsection{Implementasi Web Handler dengan Actix}

Kode di bawah ini merupakan implementasi lengkap aplikasi web sederhana menggunakan \texttt{Actix Web}, \texttt{Askama} untuk template HTML, dan \texttt{SQLx} sebagai konektor database MariaDB secara asynchronous. Aplikasi ini menampilkan nilai counter dari tabel \texttt{counter}, menyediakan tombol untuk menambah nilainya, serta dapat dijalankan secara paralel pada port yang berbeda dengan koneksi database yang berbeda pula. Pendekatan ini merepresentasikan prinsip \texttt{space-based architecture} dalam konteks distribusi beban dan sinkronisasi data antar node.

\begin{lstlisting}[style=RustStyle, caption={Implementasi server Actix Web dengan SQLx dan Askama}]
	use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder};
	use askama::Template;
	use sqlx::MySqlPool;
	use std::env;
	
	#[derive(Template)]
	#[template(path = "index.html")]
	struct IndexTemplate {
		value: i64,
	}
	
	#[derive(Template)]
	#[template(path = "view.html")]
	struct ViewTemplate {
		value: i64,
	}
	
	#[get("/")]
	async fn index(db: web::Data<MySqlPool>) -> impl Responder {
		let rec = sqlx::query!("SELECT value FROM counter WHERE name = 'web' LIMIT 1")
		.fetch_optional(db.get_ref())
		.await
		.unwrap();
		
		let value = rec.and_then(|r| r.value.map(|v| v as i64)).unwrap_or(0i64);
		let template = IndexTemplate { value };
		HttpResponse::Ok().content_type("text/html").body(template.render().unwrap())
	}
	
	#[post("/increment")]
	async fn increment(db: web::Data<MySqlPool>) -> impl Responder {
		let _ = sqlx::query!(
		r#"
		INSERT INTO counter (name, value) VALUES ('web', 1)
		ON DUPLICATE KEY UPDATE value = value + 1
		"#
		)
		.execute(db.get_ref())
		.await;
		
		HttpResponse::SeeOther()
		.insert_header(("Location", "/"))
		.finish()
	}
	
	#[get("/view")]
	async fn view_counter(db: web::Data<MySqlPool>) -> impl Responder {
		let rec = sqlx::query!("SELECT value FROM counter WHERE name = 'web' LIMIT 1")
		.fetch_optional(db.get_ref())
		.await
		.unwrap();
		
		let value = rec.and_then(|r| r.value.map(|v| v as i64)).unwrap_or(0i64);
		let template = ViewTemplate { value };
		HttpResponse::Ok().content_type("text/html").body(template.render().unwrap())
	}
	
	#[actix_web::main]
	async fn main() -> std::io::Result<()> {
		let mut args = env::args().skip(1);
		let db_url = args.next().expect("Please provide a database URL");
		let port = args
		.next()
		.expect("Please provide a port number")
		.parse::<u16>()
		.expect("Invalid port number");
		
		let db = MySqlPool::connect(&db_url)
		.await
		.expect("Failed to connect to DB");
		
		println!("Running on port {}", port);
		
		HttpServer::new(move || {
			App::new()
			.app_data(web::Data::new(db.clone()))
			.service(index)
			.service(increment)
			.service(view_counter)
		})
		.bind(("0.0.0.0", port))?
		.run()
		.await
	}
\end{lstlisting}

Kode pada listing tersebut mengimplementasikan server web menggunakan pustaka \texttt{actix-web} yang terintegrasi dengan basis data \texttt{MySQL} melalui \texttt{SQLx}, dan menggunakan \texttt{Askama} untuk menghasilkan tampilan HTML berbasis template. Pendekatan ini memungkinkan pengolahan data secara real-time dalam antarmuka web yang responsif dan modular.

Dua struktur utama \texttt{IndexTemplate} dan \texttt{ViewTemplate} mendefinisikan data yang akan dirender ke dalam template HTML. Masing-masing hanya memiliki satu properti \texttt{value} bertipe \texttt{i64}, yang akan digunakan untuk menampilkan nilai counter.

Tiga buah handler HTTP digunakan:
\begin{itemize}
	\item \texttt{index} menangani permintaan GET ke root path \texttt{/}, mengambil nilai counter dari basis data dengan query SQL, lalu menampilkannya menggunakan template \texttt{index.html}.
	\item \texttt{increment} menangani permintaan POST ke path \texttt{/increment}, dan menjalankan query SQL \texttt{INSERT} dengan klausa \texttt{ON DUPLICATE KEY UPDATE} untuk menambah nilai counter jika data sudah ada. Setelah update, pengguna diarahkan kembali ke halaman utama.
	\item \texttt{view\_counter} menangani permintaan GET ke path \texttt{/view}, yang fungsinya mirip dengan \texttt{index}, namun hanya menampilkan nilai tanpa tombol interaksi.
\end{itemize}

Fungsi utama \texttt{main()} bertugas mengambil parameter dari argumen command-line, yakni \texttt{database URL} dan \texttt{port}. Koneksi ke basis data dibuka melalui \texttt{MySqlPool}, dan server HTTP dijalankan pada port yang ditentukan. Setiap handler didaftarkan ke dalam \texttt{App} milik Actix Web dan dapat berjalan secara paralel menggunakan \texttt{HttpServer}.

Kode ini memberikan fleksibilitas untuk menjalankan beberapa instance aplikasi web di port yang berbeda, masing-masing terhubung ke node Galera yang berbeda pula. Desain ini sangat cocok untuk eksperimen arsitektur space-based karena mendemonstrasikan bagaimana beberapa unit pemrosesan dapat bekerja pada data bersama melalui replikasi basis data. Kombinasi antara query berbasis SQL, template rendering, dan kemampuan asynchronous dari Actix Web membuat aplikasi ini efisien dan mudah diskalakan.

\subsection{Template HTML untuk Tampilan Web}

Aplikasi ini menggunakan \texttt{Askama}, sebuah pustaka Rust untuk templating HTML yang berbasis pada sintaks Jinja2. Struktur template dipisahkan agar mudah dipelihara dan memungkinkan reuse tampilan melalui teknik \texttt{extends} dan \texttt{block}.

\begin{lstlisting}[language=xml, caption={templates/base.html}]
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="UTF-8">
	<title>Counter</title>
	</head>
	<body>
	{% block content %}{% endblock %}
	</body>
	</html>
\end{lstlisting}

Template \texttt{base.html} berfungsi sebagai kerangka dasar seluruh tampilan. Tag \texttt{{\% block content \%}} akan diisi oleh template yang meng-extends file ini, sehingga semua halaman memiliki struktur HTML yang konsisten tanpa harus ditulis ulang.

\begin{lstlisting}[language=xml, caption={templates/index.html}]
	{% extends "base.html" %}
	
	{% block content %}
	<h1>Counter App</h1>
	<p>Current count: {{ value }}</p>
	<form action="/increment" method="post">
	<button type="submit">Increment Counter</button>
	</form>
	{% endblock %}
\end{lstlisting}

Template \texttt{index.html} menampilkan judul aplikasi dan nilai counter saat ini yang diambil dari field \texttt{value} pada struktur data \texttt{IndexTemplate}. Tersedia pula form HTML dengan metode \texttt{POST} yang akan memicu handler \texttt{/increment} saat tombol ditekan.

\begin{lstlisting}[language=xml, caption={templates/view.html}]
	{% extends "base.html" %}
	
	{% block content %}
	<h1>Counter Viewer</h1>
	<p>Current count: {{ value }}</p>
	{% endblock %}
\end{lstlisting}

Template \texttt{view.html} hampir serupa dengan \texttt{index.html}, namun tidak menyediakan tombol untuk menambah nilai. Halaman ini hanya menampilkan informasi nilai counter, sehingga cocok dijadikan tampilan baca-saja untuk memantau hasil replikasi data antar node Galera.

Dengan pendekatan templating ini, pengembangan dan pemeliharaan antarmuka pengguna menjadi lebih terstruktur dan modular, sesuai dengan prinsip arsitektur yang baik.

\subsection{Menjalankan Aplikasi dan Menguji Fungsi}

Setelah semua konfigurasi dan implementasi selesai, langkah selanjutnya adalah menjalankan aplikasi untuk memastikan bahwa komunikasi antara \texttt{processing unit} dan database Galera Cluster berjalan dengan baik. Aplikasi ini dirancang agar dapat dijalankan dalam beberapa instance secara paralel, dengan koneksi ke node database yang berbeda namun tetap berbagi data yang sama melalui replikasi Galera.

Untuk menjalankan dua instance server pada dua node database yang berbeda, gunakan perintah berikut di dua terminal berbeda:

\begin{lstlisting}[language=bash, caption={Menjalankan dua server dengan koneksi berbeda}]
	cargo run -- mysql://root:root@127.0.0.1:3307/app_db 8080
	cargo run -- mysql://root:root@127.0.0.1:3308/app_db 8081
\end{lstlisting}

Instance pertama akan berjalan di \texttt{localhost:8080} dan terhubung ke node \texttt{galera1}, sedangkan instance kedua akan berjalan di \texttt{localhost:8081} dan terhubung ke node \texttt{galera2}. Keduanya menggunakan database \texttt{app\_db} dan tabel \texttt{counter} yang sama berkat mekanisme replikasi Galera.

\textbf{Langkah pengujian}:

\begin{enumerate}
	\item Buka browser dan akses alamat \texttt{http://localhost:8080/} pada instance pertama. Halaman ini akan menampilkan nilai awal dari \texttt{counter} dan menyediakan tombol untuk melakukan \texttt{increment}.
	\item Akses juga alamat \texttt{http://localhost:8081/view} pada instance kedua untuk menampilkan nilai counter dari node lainnya.
	\item Klik tombol \texttt{Increment} pada halaman utama instance pertama.
	\item Refresh halaman \texttt{/view} pada instance kedua. Jika replikasi berhasil, maka nilai counter akan bertambah secara otomatis.
\end{enumerate}

Dengan pendekatan ini, aplikasi mendemonstrasikan karakteristik arsitektur \texttt{space-based}, di mana data dan pemrosesan tersebar, namun tetap konsisten melalui mekanisme \texttt{eventual consistency} yang disediakan oleh Galera Cluster.

\textbf{Catatan:} Karena Galera menggunakan replikasi sinkron antar node, nilai counter seharusnya langsung terlihat konsisten di semua node dalam kondisi normal. Namun, dalam skenario nyata, tetap perlu mempertimbangkan strategi fallback dan penanganan konflik bila terjadi network partition atau node failure.


\section{Kesimpulan}

Melalui studi dan implementasi sederhana pada bab ini, konsep \textit{space-based architecture} dapat dipahami secara lebih konkret sebagai sebuah pendekatan yang memisahkan pemrosesan dan penyimpanan data dari ketergantungan terhadap titik pusat. Dengan menggunakan Galera Cluster untuk mendistribusikan data secara sinkron antar node, serta Actix Web dan SQLx untuk membangun layanan web asinkron yang ringan, diperlihatkan bagaimana unit-unit pemrosesan dapat berjalan secara paralel dan tetap menjaga konsistensi data. Aplikasi web yang dikembangkan mampu merepresentasikan prinsip utama dari arsitektur ini, yaitu pemrosesan terdistribusi, pemanfaatan shared memory, serta ketahanan sistem terhadap gangguan pada satu atau lebih node.

Penerapan arsitektur ini menjadi semakin relevan di era sistem real-time dan cloud-native, di mana skalabilitas dan ketersediaan tinggi menjadi kebutuhan dasar. Pendekatan seperti ini membuka peluang besar dalam pengembangan aplikasi yang responsif terhadap lonjakan beban, memiliki latensi rendah, dan mampu tumbuh secara elastis tanpa perubahan besar pada desain sistem. Dengan pemahaman yang kuat terhadap prinsip dan komponen space-based architecture, pengembang dapat merancang sistem yang tidak hanya efisien dan tangguh, tetapi juga adaptif terhadap dinamika kebutuhan masa depan.
